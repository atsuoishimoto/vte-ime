diff -Nur vte-0.15.2/src/pty.c vte-0.15.2.new/src/pty.c
--- vte-0.15.2/src/pty.c	2007-02-12 16:43:07.000000000 +0100
+++ vte-0.15.2.new/src/pty.c	2007-02-12 16:43:08.000000000 +0100
@@ -158,7 +158,27 @@
 		const char *name;
 		int fd;
 	} tty;
+   int keep_fd;
 };
+
+static int
+_vte_pty_keep_fd(char **env_add)
+{
+   int i, res = -1;
+   if(env_add == NULL)
+      return res;
+
+   const gchar *needle="VTE_PTY_KEEP_FD=";
+   for(i=0; env_add[i] != NULL; i++) {
+      gchar *s = strstr(env_add[i],needle);
+      if(s != NULL) {
+	 res = atoi(&s[strlen(needle)]);
+	 break;
+      }
+   }
+   return res;
+}
+
 static void 
 vte_pty_child_setup (gpointer arg)
 {
@@ -186,7 +206,6 @@
 	}
 #endif
 
-
 	/* Start a new session and become process-group leader. */
 #if defined(HAVE_SETSID) && defined(HAVE_SETPGID)
 #ifdef VTE_DEBUG
@@ -258,6 +277,20 @@
 		close(fd);
 	}
 
+	int i;
+	int keep_fd = data->keep_fd;
+	if(keep_fd > 0) {
+	   /* Close most descriptors. */
+	   for (i = 0; i < sysconf(_SC_OPEN_MAX); i++) {
+	      if (i != keep_fd &&
+		  i != fd && 
+		  i != STDOUT_FILENO && 
+		  i != STDIN_FILENO && 
+		  i != STDERR_FILENO) {
+		 close(i);
+	      }
+	   }
+	}
 
 	/* Reset our signals -- our parent may have done any number of
 	 * weird things to them. */
@@ -309,12 +342,16 @@
 		      envp2[i] = g_strdup(envp[k]);
 		   envp2[i] = NULL;
 		}
+		GSpawnFlags flags = (G_SPAWN_CHILD_INHERITS_STDIN |
+ 				     G_SPAWN_FILE_AND_ARGV_ZERO |
+ 				     G_SPAWN_SEARCH_PATH |
+ 				     G_SPAWN_DO_NOT_REAP_CHILD);
+  		data->keep_fd = _vte_pty_keep_fd(envp);
+ 		if (data->keep_fd > 0) {
+ 		   flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;
+ 		}
 		ret = g_spawn_async_with_pipes (directory,
-				arg2, envp2, 
-				G_SPAWN_CHILD_INHERITS_STDIN |
-				G_SPAWN_FILE_AND_ARGV_ZERO |
-				G_SPAWN_SEARCH_PATH |
-				G_SPAWN_DO_NOT_REAP_CHILD,
+				arg2, envp2, flags,
 				vte_pty_child_setup, data,
 				pid,
 				NULL, NULL, NULL,
@@ -345,6 +382,10 @@
 	return ret;
 }
 
+
+
+
+
 /* Open the named PTY slave, fork off a child (storing its PID in child),
  * and exec the named command in its own session as a process group leader */
 static gboolean
